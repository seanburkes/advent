/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package advent

import java.awt.Point
import java.io.File
import kotlin.collections.mutableListOf

class Tree() {

    fun getLines(file: String): List<String> {
        return File(file).useLines { it.toList() }
    }

    fun parseLinesToGrid(lines: List<String>): Array<Array<Int>> {
        var grid: Array<Array<Int>> = arrayOf()

        lines.forEach { line ->
            run {
                val row = stringToIntArray(line)
                grid = grid + arrayOf(row)
            }
        }

        return grid
    }

    fun stringToIntArray(line: String): Array<Int> {
        return line.map { it.toString().toInt() }.toTypedArray()
    }

    fun mapGridLeftRight(grid: Array<Array<Int>>): List<Point> {
        var points = mutableListOf<Point>()
        var tallest = -1
        grid.forEachIndexed { x, row -> run {
            row.forEachIndexed { y, value -> run {
                if (value > tallest) {
                    points.add(Point(x,y))
                    tallest = value
                }
            }}
            tallest = -1
            row.reversed().forEachIndexed { y, value -> run{
                if (value > tallest) {
                    points.add(Point(x, row.size-1-y))
                    tallest = value
                }
            }}
            tallest = -1
        }}
        return points
    }

    fun mapGridTopBottom(grid: Array<Array<Int>>): List<Point> {
        var points = mutableListOf<Point>()
        var tallest = -1
        grid.mapIndexed { y, col -> run {
            col.mapIndexed { x, value -> run {
                if (value > tallest) {
                    points.add(Point(x, y))
                    tallest = value
                }
            }}
            tallest = -1
            col.reversed().mapIndexed { x, value -> run{
                if (value > tallest) {
                    points.add(Point(x, col.size-1-y))
                    tallest = value
                }
            }}
            tallest = -1
        }}
        return points
    }

    fun getScores(grid: Array<Array<Int>>): List<Int> {
        var scores = mutableListOf<Int>()
        for (x in 0..grid[0].size - 1) {
            for (y in 0..grid[0].size - 1) {
                var score = getTreeScore(grid, Point(x, y))
                scores.add(score)
            }
        }
        return scores
    }

    fun getLeftValues(grid: Array<Array<Int>>, point: Point): List<Int> {
        return grid[point.x].take(point.y).reversed()
    }

    fun getRightValues(grid: Array<Array<Int>>, point: Point): List<Int> {
        return grid[point.x].drop(point.y + 1).toList()
    }

    fun getTopValues(grid: Array<Array<Int>>, point: Point): List<Int> {
        return grid.map { it[point.y] }.take(point.x).reversed()
    }

    fun getBottomValues(grid: Array<Array<Int>>, point: Point): List<Int> {
        return grid.map { it[point.y] }.drop(point.x + 1).toList()
    }

    fun countTreesSeenAtHeight(treeLine: List<Int>, house: Int): Int {
        var trees = 0
        treeLine.forEach { height ->
            run {
                if (height < house) trees++
                if (height >= house) {
                    trees++
                    return trees
                }
            }
        }
        return trees
    }

    fun getTreeScore(grid: Array<Array<Int>>, point: Point): Int {
        if (point.x == 0 ||
                        point.y == 0 ||
                        point.x == (grid[0].size - 1) ||
                        point.y == (grid[0].size - 1)
        )
                return 0

        var house = grid[point.x][point.y]

        return (countTreesSeenAtHeight(getRightValues(grid, point), house) *
                countTreesSeenAtHeight(getLeftValues(grid, point), house) *
                countTreesSeenAtHeight(getTopValues(grid, point), house) *
                countTreesSeenAtHeight(getBottomValues(grid, point), house))
    }

    fun getVisibility(grid: Array<Array<Int>>): Int {
        var fromLeftRight = mapGridLeftRight(grid)
        var fromTopBottom = mapGridTopBottom(grid)

        var coords: HashSet<Point> = hashSetOf<Point>()
        fromLeftRight.forEach { x: Point -> coords.add(x) }
        fromTopBottom.forEach { x: Point -> coords.add(x) }

        return coords.size
    }
}

fun main() {
    val file = "/home/sean/src/kotlin/advent/day8/input.txt"
    val tree = Tree()
    val lines = tree.getLines(file)
    val grid = tree.parseLinesToGrid(lines)
    println("Trees visible from outside: " + tree.getVisibility(grid))
    println("Top house score: " + tree.getScores(grid).sortedDescending().first())
}
